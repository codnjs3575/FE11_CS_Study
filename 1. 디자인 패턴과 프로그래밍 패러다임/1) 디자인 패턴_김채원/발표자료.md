# 1. 디자인 패턴을 `왜` 알아야 하는가?

---

정처기를 공부하신 분들이라면 공감하실 분들도 꽤 계실 것 같은데 필자는 정처기를 따기위해 공부했을 당시 디자인 패턴 목차에서 꽤나 애를 먹었었던 기억이 있다. **생성**(Creational), **구조**(Structural), **행위**(Behavioral)으로 나눠져있는 20여가지가 넘는 디자인 패턴을 다 외우다보면 앞에 봤던 생성 패턴들이 휘발되어진 채로 다시 1번 패턴부터 외우곤 했었다. 그 당시 정처기에서 디자인패턴 문제는 최소 1개 이상 나왔었기에 무조건 알아야 했지만 그로부터 3년이 지난 지금도 디자인패턴은 여전히 헷갈린 채 남아있다.

그도 그럴것이 디자인 패턴에 대해 왜 알아야 하는지도 모른 채 공부하였기 때문에 정처기를 딴 이후로부터는 필요없는 정보로 처리된 것이 아닐까 싶다. 그리고 운이 좋게도 CS 지식에 대해 공부하고 싶은 4명이 모인 스터디에서 나는 다시 디자인 패턴을 공부할 수 있었다. 그리고 이제는 3년 전과 다르게 공부해야 할 이유가 생겼다고 할 수 있다.

자바스크립트는 객체 지향 언어이며, React와 Next는 자바스크립트를 사용하는 대표 프레임워크이다. 지금 ‘프론트엔드’에서 가장 많이 쓰이는 언어와 프레임워크를 사용하는 만큼 **객체를 다루는 방법**에 대해서 아는 것은 중요하다고 생각했다. 물론 디자인 패턴을 공부한다고 해서 ‘난 꼭 이 디자인 패턴대로 사고하고 코드를 짤거야!’하는 것은 어리석지만 그럼에도 각각의 디자인 패턴들은 ‘왜’ 등장하였고, 왜 각각의 디자인 패턴들이 필요한 건지에 대해 아는지모르는지는 구현 뿐만 아니라 유지보수에서의 코드 품질 차이로 분명히 나타날 것이라고 생각한다.

# 2. 디자인 패턴은 `왜?` 등장했는가?

---

그렇다면 디자인 패턴은 왜 등장했을까? 왜 개발자들은 디자인 패턴이라는 개념이 필요했을까?

사실 디자인 패턴은 ‘컴퓨터 과학’의 영역이 아니라, ‘건축학’에서 먼저 등장한 개념이라고 한다.

크리스토퍼 알렉산더는 <패턴 랭귀지>라는 책을 집필하며  “패턴”이라는 개념을 건축에 적용하였다.

<image src="./assets/image0.png" width='250px' />

<패턴 랭귀지>, 크리스토퍼 알렉산더,

운이 좋게도 나는 다음 [티스토리 블로그](https://brunch.co.kr/@joongilkim/67)에서 <패턴 랭귀지> 책의 몇몇 문장들을 엿볼 수 있었는데, 다음 문단들에서 크리스토퍼 알렉산더가 패턴을 건축에 적용하고자 했던 이유를 유추해볼 수 있었다.

<image src="./assets/image1.png" width='250px' />

즉, 알렉산더는 서로 다른 개인들에게서 공통적인 패턴, 문제들을 파악하였고 이를 건축에 적용하고자 하였다. 이는 단순히 ‘멋있는 건축, 크고 웅장한 건축’에서 ‘사람을 위한 건축’으로의 시각을 보여줬다고 생각한다.

그리고 개발 또한 마찬가지이다. 컴퓨터와 소통하기 위해 개발자들은 서로 다른 각각의 소통 방식을 가지고 있기에 SOLID 원칙, HTTP 등 규약/규칙을 만들어 원활한 소통과 협업을 하고자 한다. 그래서 패턴이라는 개념을 소프트웨어, 컴퓨터 공학에 가져온 것이 바로 **GoF(네 명의 ~~갱단~~, 저자들을 일컫는 말)**라고 알려져있는, 1994년의 책 “Design Patterns: Elements of Reusable Object-Oriented Software”이다. 자바스크립트는 책이 나온 이후인 1995년에 넷스카이프 브라우저와 등장하였기에 디자인 패턴의 고려 대상은 아니었지만, 시간이 흐르며 개발자들은 GoF 패턴을 **자바스크립트의 프로토타입, 함수** 특징 그리고 더 나아가 **리액트**에도 적용하게 되었다.

<image src="./assets/image2.png" width='250px' />
> 그저 Goat, GoF

# 3. 디자인 패턴들은 JS/React 에서 어떻게 쓰일까?

신입에게 모든 디자인 패턴들에 대한 면접질문은 나오지 않을 것이라고 생각한다. 하지만 신입이라도 개발을 하면서 다음과 같은 문제들은 충분히 마주할 수 있을 것이다.

```json
1. 코드의 중복성이 높아질 때
2. 유지보수가 어려운 코드 구조를 개선할 필요가 있을 때
3. 새로운 기능을 추가하거나 변경이 쉽게 만들어야 할 때
4. 팀원들과의 협업이나 코드 가독성이 중요할 때
5. 애플리케이션의 성능이나 안정성을 높이고자 할 때
```

우리는 이러한 관점에서 앞으로 나올 디자인 패턴들을 살펴보고, 또 어떻게 적용하여 해결할 수 있을지 파악해보자.

## 3-1. Singleton

> ”싱글톤 패턴은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴입니다.”
> 스터디 주 교재, p.17 (1.1.1 싱글톤 패턴)

그렇다면 자바스크립트, 리액트에서는 어떻게 사용할 수 있을까?

1. 자바스크립트

   - **모듈 시스템** ( ESM, CommonJS )

     ```jsx
     // db.js
     class Database {
       constructor() {
         if (Database.instance) return Database.instance // 이미 있으면 재사용
         this.connection = 'connected'
         Database.instance = this
       }
     }

     const db = new Database()
     export default db
     ```

     ```jsx
     // 다른 파일
     import db1 from './db.js'
     import db2 from './db.js'

     console.log(db1 === db2) // true → 같은 인스턴스
     ```

2. React

   - State나 서비스 객체를 ‘전역적으로’ 관리하는 것과 같은 모델
   - **Zustand**와 같은 전역상태관리 라이브러리

     ```jsx
     import { create } from 'zustand'

     const useStore = create((set) => ({
       count: 0,
       increment: () => set((s) => ({ count: s.count + 1 })),
     }))

     // 컴포넌트 어디에서든 같은 store 인스턴스 사용
     // useStore는 앱 안에서 1개만 사용
     ```

## 3-2. Factory

> ”팩토리 패턴은 객체를 사용하는 코드에서 **객체 생성 부분을 떼어내 추상화한 패턴**이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴입니다.”
> 스터디 주 교재, p.24 (1.1.2 팩토리 패턴)

⇒ **객체 생성 부분을 추상화**한 패턴

- 팩토리 패턴 적용 전

  ```jsx
  class Dog {
    speak() {
      return 'woof'
    }
  }

  class Cat {
    speak() {
      return 'meow'
    }
  }

  const animalType = 'dog'
  let pet

  if (animalType === 'dog') {
    pet = new Dog()
  } else {
    pet = new Cat()
  }
  ```

  → Dog 따로, Cat 따로 로직이 흩어져 있어서 유지보수하기에 번거로움

- 팩토리 패턴 적용 후

  ```jsx
  class Dog {
    speak() {
      return 'woof'
    }
  }

  class Cat {
    speak() {
      return 'meow'
    }
  }

  class AnimalFactory {
    static createAnimal(type) {
      if (type === 'dog') return new Dog()
      if (type === 'cat') return new Cat()
      throw new Error('Unknown animal type')
    }
  }

  const pet = AnimalFactory.createAnimal('dog')
  console.log(pet.speak()) // "woof"
  ```

  → AnimalFactory로 추상화하였기에 로직이 단순해지고, 사용하기에도 편함

1. 자바스크립트

   - 객체 생성 모듈/함수
   - **Validation** 함수 (입력 검증 로직)

     ```jsx
     // validatorFactory.js
     export function createValidator(type) {
       if (type === 'email') {
         return (value) => /\S+@\S+\.\S+/.test(value)
       }
       if (type === 'password') {
         return (value) => value.length >= 8
       }
       if (type === 'username') {
         return (value) => /^[a-zA-Z0-9_]+$/.test(value)
       }
       throw new Error('Unknown validator type')
     }
     ```

     ```jsx
     // 사용처
     import { createValidator } from './validatorFactory'

     const validateEmail = createValidator('email')
     console.log(validateEmail('test@example.com')) // true
     console.log(validateEmail('invalid')) // false
     ```

2. React

   - **Variants**에 따른 **디자인 시스템** 컴포넌트 구현

     ```jsx
     function ButtonFactory({ type, ...props }) {
       if (type === "primary") return <button style={{ color: "blue" }} {...props} />;
       if (type === "secondary") return <button style={{ color: "gray" }} {...props} />;
       return <button {...props} />;
     }

     // 사용
     <ButtonFactory type="primary" children="확인" />
     <ButtonFactory type="secondary" children="취소" />
     ```

   - **Zod**를 활용한 **Validation** 함수
     생성부분을 추상화하여 제공하였기에 클라이언트(개발자)는 단순한 코드로 사용 가능

     ```jsx
     import { z } from 'zod'

     const userSchema = z.object({
       email: z.string().email(),
       password: z.string().min(8),
     })

     userSchema.parse({ email: 'test@example.com', password: '12345678' })
     ```

- **HOC**(High Order Component, 고차 컴포넌트)
  지금은 Hook이 등장하고 Custom Hook을 당연하게도 많이 사용하지만, 옛날에 컴포넌트를 인자로 받아서 새 기능이 추가된 컴포넌트를 반환하는 HOC 패턴 사용
  [[React/디자인 패턴] HOC 패턴](https://cottonwood-moa.tistory.com/154)

  ```jsx
  // 기본적인 HOC 패턴
  function withExample(WrappedComponent) {
    return class extends React.Component {
      render() {
        return <WrappedComponent {...this.props} />
      }
    }
  }
  ```

  - 클래스 컴포넌트에서의 HOC 패턴 + 생명주기메서드 사용

    - 데이터 Fetch 함수

      ```jsx
      function withData(WrappedComponent, dataSource) {
        return class extends React.Component {
          constructor(props) {
            super(props)
            this.state = {
              data: null,
              loading: true,
              error: null,
            }
          }

          componentDidMount() {
            this.fetchData()
          }

          fetchData() {
            this.setState({ loading: true })

            fetch(dataSource)
              .then((response) => response.json())
              .then((data) => {
                this.setState({
                  data: data,
                  loading: false,
                })
              })
              .catch((error) => {
                this.setState({
                  loading: false,
                  error: error,
                })
              })
          }

          render() {
            const { data, loading, error } = this.state

            return (
              <WrappedComponent
                data={data}
                loading={loading}
                error={error}
                {...this.props}
              />
            )
          }
        }
      }

      // 사용 예시
      class UserList extends React.Component {
        render() {
          const { data, loading, error } = this.props

          if (loading) return <div>로딩 중...</div>
          if (error) return <div>에러 발생: {error.message}</div>

          return (
            <ul>
              {data.map((user) => (
                <li key={user.id}>{user.name}</li>
              ))}
            </ul>
          )
        }
      }

      const UserListWithData = withData(
        UserList,
        'https://api.example.com/users'
      )
      ```

## 3-3. Strategy

> ”전략 패턴은 객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 **‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서** 상호 교체가 가능하게 만드는 패턴입니다.”
> 스터디 주 교재, p.29 (1.1.3 전략 패턴)

- passport : 인증인가 전략
  ```jsx
  passport.use(new LocalStrategy())
  passport.use(new JWTStrategy())
  passport.use(new SocialStrategy() - Kakao)
  passport.use(new SocialStrategy() - Google)
  ```

1. 자바스크립트

   [(번역) 자바스크립트에서 전략 디자인 패턴의 힘](https://velog.io/@lky5697/the-power-of-strategy-design-pattern-in-javascript)

   - **서로 다른 데이터**들을 받는 **Sorting**
     ```jsx
     function sort(items) {
       const type = typeof items[0]
       sorter.use(
         type === 'number'
           ? numberSorter
           : type === 'string'
           ? letterSorter
           : items[0] instanceof Date
           ? dateSorter
           : items[0] && type === 'object' && 'tagName' in items[0]
           ? domElementSizeSorter
           : Array.prototype.sort.bind(Array)
       )
       return [...items].sort(sorter.sort.bind(sorter))
     }
     ```
   - if-else 패턴을 **전략 패턴**으로 치환
     조건문이 너무 많아서 분기점마다 처리해야 하는 로직들이 다를 때

     ```jsx
     // 전략 모음
     const pricingStrategies = {
       normal: (price) => price,
       student: (price) => price * 0.8,
       vip: (price) => price * 0.7,
     }

     // 실행부
     function getPrice(price, type = 'normal') {
       return (pricingStrategies[type] ?? pricingStrategies.normal)(price)
     }

     // 사용
     getPrice(10000, 'student') // 8000
     ```

     → 어라? 근데 아까 factory에서 type에 따른 디자인 시스템 보여주는 거랑 뭐가 다르지?
     바로, **생성 패턴**과 **행위 패턴**의 차이!
     factory 패턴의 디자인 시스템 컴포넌트 : 어떤 컴포넌트 생성할 지 보여주는 **생성 패턴 (무엇을)**

     - ButtonFactory(type) → PrimaryButton 인스턴스? SecondaryButton 인스턴스?
       Strategy 패턴의 할인율 적용 함수 : 어떤 알고리즘/행동을 동작할 지 보여주는 **행위 패턴 (어떻게)**
     - pricingStrategies(type) → 0.8 할인율? 0.7 할인율?

2. React

   - 런타임 중 교체 동작할 수 있는 모든 로직들에 적용 가능
   - **정렬/필터 util** 함수

     ```jsx
     // List.tsx
     export function List({
       items,
       sortStrategy,
       filterStrategy = () => true,
     }) {
       const visible = items.filter(filterStrategy).sort(sortStrategy)
       return (
         <ul>
           {visible.map((i) => (
             <li key={i.id}>{i.label}</li>
           ))}
         </ul>
       )
     }

     // 전략들
     export const sortByDate = (a, b) => new Date(b.date) - new Date(a.date)
     export const sortByName = (a, b) => a.label.localeCompare(b.label)
     export const filterOnlyActive = (i) => i.active

     // 사용
     ;<List
       items={data}
       sortStrategy={sortByDate}
       filterStrategy={filterOnlyActive}
     />
     ```

   - **LocalAuth/SocialAuth API 호출 전략**→ 어떤 전략(API)을 사용할 지

     ```jsx
     // useAuth.ts
     import * as React from 'react'

     export function useAuth(strategy) {
       const [user, setUser] = React.useState(null)

       const login = async (cred) => setUser(await strategy.login(cred))
       const logout = async () => {
         await strategy.logout()
         setUser(null)
       }

       return { user, login, logout }
     }

     // 전략 예시
     const localAuth = {
       login: ({ email, password }) => api.post('/login', { email, password }),
       logout: () => api.post('/logout'),
     }

     const googleAuth = {
       login: () => googleSignIn(), // 외부 SDK
       logout: () => googleSignOut(),
     }

     // 사용
     function LoginPage() {
       const { user, login, logout } = useAuth(
         process.env.USE_GOOGLE ? googleAuth : localAuth
       )
       /* ... */
     }
     ```

   - **페이지/도메인별 Validation** 전략 교체

     ```jsx
     // validators.ts
     export const validators = {
       signup: (v) => /\S+@\S+\.\S+/.test(v.email) && v.password?.length >= 8,
       login: (v) => !!v.email && !!v.password,
     }

     // Form.tsx
     export function Form({ mode, onSubmit }) {
       const validate = validators[mode] ?? (() => false)
       const [values, setValues] = React.useState({ email: '', password: '' })

       const handleSubmit = (e) => {
         e.preventDefault()
         if (!validate(values)) return alert('입력값을 확인하세요')
         onSubmit(values)
       }

       /* inputs ... */
     }
     ```

   - **컴포넌트 렌더링 전략 교체** (팩토리가 아니라 전략 패턴임에 집중!)

     - Item을 생성하는 컴포넌트는 하나이지만 그 안에 어떤 형태/동작으로 보여줄 지 정해주는 전략 패턴

     ```jsx
     // ItemList.tsx
     const renderStrategies = {
       compact: (item) => <li key={item.id}>{item.label}</li>,
       card: (item) => (
         <li key={item.id}>
           <article className="card">
             <h4>{item.label}</h4>
             <p>{item.desc}</p>
           </article>
         </li>
       ),
     }

     export function ItemList({ items, variant = 'compact' }) {
       const render = renderStrategies[variant] ?? renderStrategies.compact
       return <ul>{items.map(render)}</ul>
     }
     ```

## 3-4. Observer

> ”옵저버 패턴은 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.”
> 스터디 주 교재, p.34 (1.1.4 옵저버 패턴)

- p.36, **옵저버 패턴** → 이벤트 기반 시스템이기에 **MVC 패턴**에서도 사용된다!

- **옵저버 패턴**은 객체 간의 변경 알림 및 구독(발행 - 구독)에 초점을 둔 **행동 패턴**
  - 한 번의 객체 변경이 여러 객체에 영향을 줄 때 유용!
- **MVC 패턴**은 옵저버 패턴을 활용한 **아키텍처** (사실, 디자인 패턴보다는 아키텍처 패턴!)
  → MVVM, MVP, Flux/Redux, FSD 아키텍처와 같은 아키텍처 패턴의 한 종류

1. 자바스크립트

   - 브라우저 DOM 이벤트들 : **addEventListener**
     ```jsx
     const onClick = (e) => console.log(e.clientX, e.clientY)
     // 구독
     document.addEventListener('click', onClick) // 클릭 시 모든 옵저버에게 알림
     // 구독 해제
     document.removeEventListener('click', onClick)
     ```
   - **Redux** : store.subscribe(listener) → 상태 변경 시 리스너 호출.

     ```jsx
     import { createStore } from 'redux'

     // Reducer
     function counterReducer(state = { count: 0 }, action) {
       switch (action.type) {
         case 'INCREMENT':
           return { count: state.count + 1 }
         case 'DECREMENT':
           return { count: state.count - 1 }
         default:
           return state
       }
     }

     // Store 생성
     const store = createStore(counterReducer)

     // 옵저버(구독자) 등록
     const unsubscribe = store.subscribe(() => {
       console.log('State changed:', store.getState())
     })

     // 상태 변경 (알림 발생)
     store.dispatch({ type: 'INCREMENT' }) // 콘솔: State changed: { count: 1 }
     store.dispatch({ type: 'INCREMENT' }) // 콘솔: State changed: { count: 2 }
     store.dispatch({ type: 'DECREMENT' }) // 콘솔: State changed: { count: 1 }

     // 구독 해제
     unsubscribe()
     ```

   - 브라우저 내장 **Observer**
     - **MutationObserver** : DOM 변경 감지
     - **IntersectionObserver** : 요소가 뷰포트/루트와 교차할 때 알림(무한 스크롤, 지연 로딩)
       https://velog.io/@khy226/intersection-observer%EB%9E%80-feat-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0
     - **ResizeObserver** : 요소 크기 변경 감지
   - **WebSocker**
     - **Subject (발행자)**: WebSocket 객체 (ws)
     - **Observers (구독자)**: 우리가 등록하는 이벤트 핸들러(onmessage, onopen, onclose)
     - **상태 변화**: 서버에서 메시지가 오거나 연결 상태가 변할 때 → WebSocket이 모든 구독자에게 알림

1. React

   - **useState 훅**

     - setState나 useState의 setter가 호출되면 React가 구독 중인 컴포넌트들에게 “변경됨”을 알리고, 컴포넌트가 **리렌더링**됨

     ```jsx
     function Counter() {
       const [count, setCount] = React.useState(0)

       return (
         <>
           <p>{count}</p>
           <button onClick={() => setCount((c) => c + 1)}>+</button>
         </>
       )
     }
     ```

   - **useEffect 훅**
     - 특정 값(state, props 등)을 관찰(**구독**)하다가 변경되면 **콜백** 실행.
     ```jsx
     function Logger({ value }) {
       React.useEffect(() => {
         console.log('📢 값이 바뀜:', value)
       }, [value]) // value = Subject, effect = Observer
     }
     ```

## 3-5. Proxy

> ”프록시 패턴은 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴입니다.”
> 스터디 주 교재, p.44 (1.1.5 프록시 패턴)

SRING이라는 프로젝트를 개발할 당시, API 호출을 하면서 문제가 발생했었고 그 때 같이 봐주셨던 협업자분께서 이건 왜 발생하는 문제이며, 어떻게 해결을 할 수 있는지에 대해 알려주셨었다.

문제상황은 이러하였다. 나는 그때 당시 로컬 환경에서 작업을 하는 FE 였기에 (localhost) 주소였고, BackEnd는 Sring.my라는 주소를 사용했었다. 그리고 CORS라는 문제가 나왔었는데, 서로 다른 주소의 호스트 이름이라면 HTTP 요청을 보낼 수 없는 문제였다. 그 때 나는 Proxy 서버라는 것을 처음으로 사용해보았다.

- CORS

```jsx
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import svgr from 'vite-plugin-svgr'

export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'https://test.sring.my', // 실제 API 서버 주소
        changeOrigin: true, // 호스트 헤더 변경
        rewrite: (path) => path.replace(/^\/api/, ''), // /api 제거
      },
    },
  },
  plugins: [react(), svgr()],
})
```

## 3-6. iterator

> ”이터레이터 패턴은 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴입니다.”
> 스터디 주 교재, p.49 (1.1.6 이터레이터 패턴)

1. 자바스크립트

   - 순차적으로 접근할 수 있는 패턴
     [Well Known Symbol](https://www.notion.so/Well-Known-Symbol-280cf2d3796180e2a1a4d6873153b243?pvs=21)

     - for of, 전개 연산자

       ```jsx
       for (const value of arr) {
         console.log(value)
       }

       console.log([...arr]) // [1, 2, 3]
       ```

     - Map, Set
       <image src="./assets/image3.png" width='250px' />

1. React

   - 리스트 렌더링
     ```jsx
     function TodoList({ todos }) {
       return (
         <ul>
           {todos.map((todo) => (
             <li key={todo.id}>{todo.text}</li>
           ))}
         </ul>
       )
     }
     ```
   - 페이지네이션

     ```jsx
     function* paginate(data, size) {
       for (let i = 0; i < data.length; i += size) {
         yield data.slice(i, i + size)
       }
     }

     function PaginatedList({ items }) {
       const [page, setPage] = React.useState(0)
       const pages = [...paginate(items, 5)]
       return (
         <div>
           <ul>
             {pages[page].map((item, i) => (
               <li key={i}>{item}</li>
             ))}
           </ul>
           <button disabled={page === 0} onClick={() => setPage((p) => p - 1)}>
             Prev
           </button>
           <button
             disabled={page === pages.length - 1}
             onClick={() => setPage((p) => p + 1)}
           >
             Next
           </button>
         </div>
       )
     }
     ```

## 3-7. Revealing module

> ”노출모듈 패턴은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말합니다.”
> 스터디 주 교재, p.51 (1.1.7 노출모듈 패턴)

- 내부 변수/함수는 은닉(캡슐화)하고, 외부에 공개할 인터페이스만 reveal(노출)함

[javascript 모듈의 등장 배경, 티스토리 블로그 <상심한 개발자>](https://codnjs3575.tistory.com/42)

- React : Custom Hook

  - 정해진 action만 가능하도록 제어 (

  ```jsx
  function useCounter(initial = 0) {
    // private state
    const [count, setCount] = React.useState(initial)

    // private helpers
    const increment = () => setCount((c) => c + 1)
    const decrement = () => setCount((c) => c - 1)

    // public API (노출되는 부분)
    return { count, increment, decrement }
  }

  // 사용
  function CounterComponent() {
    const { count, increment, decrement } = useCounter(0)
    return (
      <div>
        <p>{count}</p>
        <button onClick={increment}>+</button>
        <button onClick={decrement}>-</button>
      </div>
    )
  }
  ```

모든 디자인 패턴과 JS/React 적용 코드들을 살펴본 지금, 다시 한 번 위에서 봤던 ‘신입’으로 마주할 수 있는 질문 리스트들을 훑어보자. 우리는 어떻게 문제들을 해결할 수 있을까? 디자인 패턴에 대해 훑어본 지금, 조금은 예상이 가는 답변들이 머릿 속에 떠오를 수 있을 것 같다.

```json
1. 코드의 중복성이 높아질 때
	•	팩토리 패턴: 객체 생성 로직을 한 곳으로 모아 중복 제거.

2. 유지보수가 어려운 코드 구조를 개선할 필요가 있을 때
	•	옵저버 패턴: 결합도를 낮춰 이벤트 기반으로 동작. (ex. React 이벤트 시스템)
	•	MVC/MVVM: 역할을 분리해 관심사 분리.

3. 새로운 기능을 추가하거나 변경이 쉽게 만들어야 할 때
	•	전략 패턴: 알고리즘을 교체 가능하게 분리. (ex. 정렬 방식, 로그인 방식 변경)

4. 팀원들과의 협업이나 코드 가독성이 중요할 때
	•	공통 언어 제공: “싱글톤 쓰자”, “옵저버로 풀자” -> 협업용 언어로 사용 가능
	•	컴포지트, 어댑터, 프록시 등은 구조를 일정한 패턴으로 통일 -> 가독성 상승

5. 애플리케이션의 성능이나 안정성을 높이고자 할 때
	•	싱글톤 패턴: 전역적으로 하나의 인스턴스만 사용해 자원 관리.
	•	프록시 패턴: 캐싱/지연 로딩을 통해 성능 개선.
```

앞서도 말했다싶이 신입에게 대단한 디자인 패턴 적용 사례라던지, 모든 디자인 패턴을 암기한 지원자를 요구하는 회사는 극히 적을 것이다. 하지만 그럼에도 디자인 패턴을 알게되면 코드를 작성하고 더 나아가 프로젝트를 완성하는 데에 넓게 볼 수 있는 시각과 함께 디테일도 챙길 수 있다는 것에는 긍정적인 생각 그대로 변함이 없다. 마지막으로는 면접에서 ‘디자인 패턴’과 관련있는 질문으로 나올 수 있는 리스트들을 모아보았다.

- 면접 질문
  ### **1. 개념 이해**
  - 디자인 패턴이란 무엇인가요?
  - 왜 디자인 패턴이 필요할까요?
  - GoF 책에서 말하는 디자인 패턴은 어떻게 분류되나요? (생성, 구조, 행위)
    👉 “반복적으로 등장하는 문제를 해결하기 위한 검증된 설계 방식, 협업을 위한 공통 언어”
  ***
  ### **2. 대표 패턴 설명**
  - 싱글톤 패턴이 무엇이고, 자바스크립트/리액트에서는 어떻게 적용할 수 있나요?
  - 옵저버 패턴이 무엇이며, 프론트엔드에서의 예시는 무엇이 있을까요? (ex. addEventListener, pub/sub)
  - 전략 패턴(Strategy pattern)을 아는가? (콜백, 고차함수와 연관지어 설명 가능)
    👉 개념 설명 + JS/React에서의 예시(이벤트 리스너, Context API, 전역 상태 관리 등).
  ***
  ### **3. 실제 적용/비판적 시각**
  - 패턴을 남용했을 때 어떤 문제가 생길까요?
  - 모든 상황에서 디자인 패턴을 적용하는 것이 좋은 걸까요?
  - 최근 프로젝트에서 패턴을 의식적으로 적용한 경험이 있나요?
    👉 “무조건 쓰는 게 아니라, 상황에 맞게 선택해야 한다” → 과잉 추상화/불필요한 복잡성 언급
  ***
  ### **4. 프론트엔드 관점 질문**
  - React에서 흔히 볼 수 있는 패턴에는 무엇이 있나요?
    (예: HOC, Render Props, Custom Hooks → 사실상 디자인 패턴의 일종)
  - 상태 관리에서 사용되는 디자인 패턴이 있다면?
    (싱글톤 → Store, 옵저버 → Redux의 subscribe, Mediator → Context API 등)
  - 컴포넌트 설계할 때 어떤 패턴을 의식하나요?
    (Container-Presenter, Compound Component, Controlled vs Uncontrolled)
    👉 React 생태계의 패턴
