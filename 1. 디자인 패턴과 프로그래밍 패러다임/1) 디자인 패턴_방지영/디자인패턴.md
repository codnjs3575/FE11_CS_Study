### 🔍 디자인 패턴이란 ?

디자인 패턴은 소프트웨어에서 **자주 발생하는 문제에 대해 재사용이 가능한 해결책**이다.

디자인 패턴에서는 특정 상황에 특화되어 있는 해결책이 아닌 일반적인 상황에 적용할 수 있는 방법을 제안한다. 그래서 소프트웨어 시스템에서 보다 유연하고 확장 가능성이 높은 설계가 가능해진다.

또한, 다른 개발자들이 쉽게 이해하고 적용할 수 있도록 패턴별 문제 상황 / 해결 방법 / 구현 예제로 구분하여 문서화되어 있다. 개발자들의 공통된 형태의 언어를 이해하고 공유함으로써 코드의 일관성을 높이고 유지보수성을 향상시킬 수 있다.

이러한 디자인 패턴의 특성으로 인해, 디자인 패턴을 활용하게 되면 개발하면서 마주하게 되는 새로운 문제들에 비교적 쉽고 빠르게 대응인 가능해지는 것이다.

#### 🧐 디자인 패턴 개념은 언제 등장했을까 ?

사실 디자인 패턴의 개념은 소프트 웨어 공학 분야에서 처음 등장한 것은 아니었다. 건축학에서 발생하는 특정 구조나 문제에 대한 일반적인 형태의 해결책을 정리한 디자인 패턴 개념을 소프트웨어 공학 분야에 적용시킨 것이었다.

그래서 소프트웨어 공학 분야에서 디자인 패턴의 개념이 명확하게 정리된 것은 1994년 4명의 컴퓨터 과학 연구자, GoF가 **Design Patterns**: Elements of Reusable Object-Oriented Software 을 출판했을 때이다.

#### 💡 디자인 패턴 종류

해당 책에서 소개되는 디자인 패턴의 종류는 크게 생성 패턴 / 구조 패턴 / 행위 패턴 으로 분류된다.
아래는 각 분류에 대한 대표적인 3가지 패턴을 정리한 내용이다.

<table>
  <tr>
    <td><b>생성 패턴</b></td>
    <td>객체를 생성하는 방식이나 객체 생성 시점을 결정하는 패턴</td>
  </tr>
  <tr>
    <td><b>구조 패턴</b></td>
    <td>클래스와 객체를 조합하여 더 큰 구조를 만드는 방법에 대한 패턴</td>
  </tr>
  <tr>
    <td><b>행위 패턴</b></td>
    <td>객체나 클래스 사이의 상호작용과 책임 분배 방법을 정의한 패턴</td>
  </tr>
</table>

각 패턴의 속한 디자인 패턴 종류는 너무나도 다양하다..🤯
JS에서 자주 사용되고 중요하다고 생각되는 패턴 3가지에 대해서만 정리해보고자 한다.

---

### ✨ 싱글톤 패턴

##### 📍 싱글톤 패턴 (Singleton Pattern) 은 ?

> 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다.
> 이러한 패턴을 기반으로 프로그램 내에서 하나의 객체만을 생성하여 이를 공유하여 사용해야 할 때 주로 사용됩니다.

#### 👍🏻 싱글톤 패턴의 이점

**공간 메모리 절약**
한개의 인스턴스만을 고정 메모리 영역에 생성하고 추후 해당 객체를 접근할 때 메모리 낭비를 방지할 수 있다.

**접근 속도 향상**
생성된 인스턴스를 사용할 때는 이미 생성된 인스턴스를 활용하여 속도가 비교적 빠르다.

**데이터 공유**
전역으로 사용하는 인스턴스이기 때문에 여러 클래스에서 데이터를 공유할 수 있다.
하지만 동시에 접근할 경우 동시성 문제가 발생할 수 있으므로 주의하여 설계해야 한다.

#### 🔗 Javascript 예시 코드

```js
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
  getInstance() {
    return this;
  }
}

const a = new Singleton();
const b = new Singleton();

console.log(a === b); // true
```

✅ Singleton.instance 라는 하나의 인스턴스를 가지는 Singleton 클래스 구현.
이를 통해 a와 b는 하나의 인스턴스를 가지게 된다.

#### 🔗 Zustand - Singleton Pattern

```js
// store/counterStore.js
import { create } from 'zustand';

export const useCounterStore = create((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
}));
```

✅ Zustand는 create()로 생성된 store를 전역적으로 단 하나만 유지한다.

```js
// components/Counter.jsx
import { useCounterStore } from '../store/counterStore';

export default function Counter() {
  const { count, increase } = useCounterStore();

  return (
    <div>
      <h3>Counter</h3>
      <p>Count: {count}</p>
      <button onClick={increase}>+</button>
    </div>
  );
}
```

✅ 이 store는 싱글톤처럼 동작하므로, import하면 항상 동일한 인스턴스를 참조한다.

#### ⚠️ 싱글톤 패턴의 단점

단위 테스트를 주로 수행하는 TDD 를 적용할 경우, 각 테스트가 서로 독립적이어야 하기 때문에 문제가 될 수 있다. 싱글톤 패턴은 하나의 인스턴스를 활용해 개발하기 때문에 독립적인 인스턴스를 갖기 어렵기 때문이다.

---

### ✨ 팩토리 패턴

##### 📍 팩토리 패턴 (Factory Pattern) 은 ?

> 팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정하게 만드는 패턴이다.

#### 👍🏻 팩토리 패턴의 이점

**낮은 결합도**
크리에이터와 구상 제품들이 단단하게 결합되지 않도록 할 수 있다.

**유지보수성 향상**
한 클래스는 한가지 부분만 담당하기 때문에 유지/보수하기 쉽다.

**높은 유연성**
유연성이 높아 기존 클라이언트 코드를 훼손하지 않고 새로운 유형의 제품들을 프로그램에 도입할 수 있다.

#### 🔗 Javascript 예시 코드

```js
// 공통 인터페이스 역할을 하는 클래스
class User {
  constructor(name) {
    this.name = name;
  }

  accessPage() {
    console.log(`${this.name}님은 기본 페이지에 접근합니다.`);
  }
}

// 서브 클래스
class AdminUser extends User {
  accessPage() {
    console.log(`${this.name}님은 관리자 페이지에 접근합니다.`);
  }
}

class NormalUser extends User {
  accessPage() {
    console.log(`${this.name}님은 일반 사용자 페이지에 접근합니다.`);
  }
}

class GuestUser extends User {
  accessPage() {
    console.log(`${this.name}님은 게스트 전용 페이지에 접근합니다.`);
  }
}

// 팩토리 클래스
class UserFactory {
  static createUser(role, name) {
    switch (role) {
      case 'admin':
        return new AdminUser(name);
      case 'user':
        return new NormalUser(name);
      case 'guest':
        return new GuestUser(name);
      default:
        throw new Error('Unknown role type');
    }
  }
}

// 사용 예시
const admin = UserFactory.createUser('admin', '지영');
const user = UserFactory.createUser('user', '민수');
const guest = UserFactory.createUser('guest', '하나');

admin.accessPage(); // 지영님은 관리자 페이지에 접근합니다.
user.accessPage(); // 민수님은 일반 사용자 페이지에 접근합니다.
guest.accessPage(); // 하나님은 게스트 전용 페이지에 접근합니다.
```

✅ `UserFactory` : 객체 생성 전담
생성 로직을 모아서 관리하기 때문에 유지보수성 ↑ 결합도 ↓

#### ⚠️ 팩토리 패턴의 단점

팩토리 중첩 등 구조가 복잡해지면 추적이 어려워져서 디버깅이 어려워 질 수 있다.
팩토리 구조 필요성이 낮은 부분에 도입하게 되면 불필요하게 코드 복잡도를 증가시킬 수 있다. 따라서 규모가 작은 프로젝트에는 적합하지 않다.

---

### ✨ 옵저버 패턴

##### 📍 옵저버 패턴 (Observer Pattern) 은 ?

> 주체가 어떤 상태를 관찰하다가 상태 변화가 감지될 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴.

#### 👍🏻 옵저버 패턴의 이점

**낮은 결합도**
주체와 옵저버가 직접적인 의존 관계를 가지지 않기 때문에, 서로의 내부 구조를 몰라도 상호 작용이 가능하다.

**상태 변화 감지 용이**
주체의 상태가 바뀌면 모든 옵저버에게 자동으로 알림이 전달되어 데이터의 일관성을 유지할 수 있다.

**이벤트 기반 구조 적용**
사용자 인터랙션, 비동기 통신, 데이터 갱신 등 다양한 상황에서 유연하게 적용할 수 있다.

#### 🔗 Javascript 예시 코드

```js
// Subject
const button = document.createElement('button');
button.textContent = '클릭해보디';
document.body.appendChild(button);

// Observer
function handleClickA() {
  console.log('옵저버 A: 버튼이 클릭되었디!');
}

function handleClickB() {
  console.log('옵저버 B: 버튼 클릭 감지했디!');
}

// 상태 변화 구독
button.addEventListener('click', handleClickA);
button.addEventListener('click', handleClickB);
```

✅ `button` 주체의 상태를 구독하여 상태에 `click`이 감지될 경우, `handleClickA` 와 `handleClickB` 가 작동된다.

#### 🔗 Redux - Observer 패턴

```js
import { createStore } from 'redux';

// Subject
const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    default:
      return state;
  }
};

const store = createStore(counterReducer);

// Observer
store.subscribe(() => {
  console.log('상태 변경 감지:', store.getState());
});

// 상태 구독
store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'INCREMENT' });
```

✅ `store.subscribe()`를 통해 상태 변화가 감지되면 store의 `INCREMENT` 타입의 dispatch 가 실행된다.

#### ⚠️ 옵저버 패턴의 단점

옵저버의 수가 많아질수록 의존 관계가 복잡해지고, 메모리 누수나 순환 참조 문제가 발생할 수 있다. 또한, 한 번의 상태 변경이 많은 옵저버에게 알림을 전달하게 되어 성능 부하가 커질 수 있다.
옵저버 간 상호 작용이 연쇄적으로 일어나면, 전체 시스템의 동작을 예측하기 힘들어져 디버깅이 어려워진다.

---

### 📖 정리하며..

다양한 디자인 패턴 중 3가지 패턴의 장단점 및 예시 코드를 정리해 보았다. JS에서 많이 쓰이는 형식의 패턴이었기 때문에 예시 코드를 보며 구조의 특성을 이해하기에 어렵지 않았다. 이런 형태가 어떤 패턴으로 정의되어 있구나, 어떤 장점을 가지고 있구나에 대해 정리해볼 수 있었다.

그래도 전반적으로 구조에 대한 이해도가 높아져 코드의 구조 및 특성 파악에 도움이 되었다. 이후에 추가적으로 다른 디자인 패턴에 대해서도 학습하게 된다면 코드를 이해하는 시야를 더욱 넓힐 수 있을 것 같다.

#### 💬 면접 질문

**싱글톤 패턴은 어떤 상황에서 사용하는 것이 적절한가요?**

싱글톤 패턴은 공유 자원을 전역적으로 관리해야 할 때 적합합니다.
예를 들어 전역 설정, 로깅, 상태 관리, 데이터베이스 연결 객체 등이 해당됩니다.
다만 너무 많은 역할을 맡기면 코드 의존도가 높아지고 테스트가 어려워질 수 있습니다.

**옵저버 패턴을 잘못 사용했을 때 어떤 문제가 발생하나요?**

옵저버 패턴은 상태 변경 시 자동으로 알림이 전달되지만,
관계가 복잡하거나 옵저버 수가 많을 경우 디버깅이 어려워질 수 있습니다.
또한 옵저버 간의 의존이 꼬이면 예측 불가능한 이벤트 루프나 메모리 누수가 생길 수 있습니다.

**팩토리 패턴을 적용하기 좋은 시점은 언제인가요?**

객체의 생성 과정이 복잡하거나, 여러 타입의 객체를 유연하게 생성해야 할 때 적합합니다.
코드 수정 없이 새로운 객체를 추가할 수 있어 확장성이 뛰어납니다.
하지만 단순한 구조에 적용하면 오히려 불필요한 추상화로 복잡도만 늘어날 수 있습니다.
