우선, FE 가 데이터베이스에 대해 알아야할까 ? 🤔

이번 백엔드 협업 프로젝트를 진행하면서, 어떤 부분이 원하는대로 구현되지 않을 때 백엔드 로직 및 데이터베이스에 대한 이해가 있어야 정확히 필요한 부분을 요청할 수 있겠다는 생각이 들었다 ..!

### 🔍 데이터베이스란 ?

일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음.

##### 📍 릴레이션

> 데이터베이스에서 정보를 구분하여 저장하는 기본 단위.
> 엔터티 관한 데이터는 하나의 릴레이션에서 관리하며 관계형 데이터베이스에서는 테이블이라고 부른다.

✅ **엔터티 :** 여러 개의 속성을 지닌 명사를 의미.

##### 📍 도메인

> 릴레이션에 포함된 각각의 속성들이 가질 수 없는 값의 집합을 의미.

✅ 성별 속성의 도메인 : Male / Female

그래서 데이터베이스는 속성 이름인 `필드`와 속성의 값인 `레코드` 로 구성된다.

#### ✨ 키 종류

| 키 종류    | 의미                                       | 특징 / 역할                                    |
| ---------- | ------------------------------------------ | ---------------------------------------------- |
| **기본키** | 테이블에서 각 행을 유일하게 식별하는 키    | 중복 X, NULL X                                 |
| **외래키** | 다른 테이블의 기본키를 참조하는 키\*       | 테이블 간 **관계** 표현                        |
| **후보키** | 기본키로 될 수 있는 모든 키 후보들         | 유일성 O, NULL X                               |
| **대체키** | 후보키 중 기본키로 선택되지 않은 키        | 기본키의 대안 키                               |
| **슈퍼키** | 행을 유일하게 구분할 수 있는 속성들의 집합 | 후보키보다 넓은 개념 (불필요한 속성 포함 가능) |

#### 💡 정규화 과정

| 정규형      | 핵심 개념                                      | 조건 / 규칙                            |
| ----------- | ---------------------------------------------- | -------------------------------------- |
| **1정규형** | 모든 컬럼이 **원자값(atomic value)** 이어야 함 | 한 칸(열)에 여러 값 X                  |
| **2정규형** | **부분 함수 종속 제거**                        | 기본키의 일부에만 종속된 속성 X        |
| **3정규형** | **이행적 종속 제거**                           | 비키가 다른 비키에 의존 X              |
| **BCNF**    | **모든 결정자가 후보키**여야 함                | 후보키 아닌 결정자 X                   |
| **4정규형** | **다치 종속 제거**                             | 한 키가 여러 독립적인 값 집합 가지면 X |
| **5정규형** | **조인 종속 제거**                             | 조인으로만 표현 가능한 종속 관계 X     |

### 🔍 트랜잭션이란 ?

##### 📍 트랜잭션

> 데이터베이스에서 수행되는 작업 단위로, 여러 쿼리들을 하나로 묶는 단위를 말한다.

#### ✨ 핵심 개념

" 모두 성공하거나 모두 실패해야 한다. "

```
BEGIN TRANSACTION
  UPDATE accounts SET balance = balance - 100000 WHERE id = 'A';
  UPDATE accounts SET balance = balance + 100000 WHERE id = 'B';
COMMIT;

```

데이터를 안전하게 처리하기 위해 중간에 오류가 나면 `Rollback` 으로 이전 상태로 되돌리고, 전부 성공하면 `COMMIT` 으로 확정 짓는다.

#### 💡 특징

<table>
  <tr>
    <td><b>원자성</b></td>
    <td>관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징</td>
  </tr>
  <tr>
    <td><b>일관성</b></td>
    <td>허용된 방식으로만 데이터를 변경해야 하는 것</td>
  </tr>
  <tr>
    <td><b>격리성</b></td>
    <td>트랜잭션 수행 시 서로 끼어들지 못하는 것</td>
  </tr>
  <tr>
    <td><b>지속성</b></td>
    <td>성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것</td>
  </tr>
</table>

##### 📍 무결성

> 데이터의 정확성, 일관성, 유효성을 유지하는 것으로, 무결성이 유지되어야 데이터베이스에 저장된 값과 실제 입력된 값이 같은지에 대한 신뢰가 생깁니다.

<table>
  <tr>
    <td><b>개체 무결성</b></td>
    <td>기본키로 선택된 필드는 빈 값을 허용하지 않습니다.</td>
  </tr>
  <tr>
    <td><b>참조 무결성</b></td>
    <td>서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 합니다.</td>
  </tr>
  <tr>
    <td><b>고유 무결성</b></td>
    <td>특정 속성에 관한 고유한 값을 가지도록 조건이 주어진 경우, 그 속성 값은 모두 고유한 값을 가집니다.</td>
  </tr>
  <tr>
    <td><b>NULL 무결성</b></td>
    <td>특정 속성 값에 NULL 이 올 수 없다는 조건이 주어진 경우, 그 속성은 NULL 이 올 수 없다는 제약 조건입니다.</td>
  </tr>
</table>

---

### 🔍 관계형 데이터베이스란 ?

행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터 베이스로, SQL 언어로 조작한다.

##### 📍 조인

> 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것.

#### ✨ 조인의 종류

<image src="./assets/image.png" width='450px' />

##### INNER JOIN

```sql
SELECT u.name, o.amount
FROM users u
INNER JOIN orders o ON u.id = o.user_id;
```

✅ 두 테이블 모두에 공통된 데이터만 조회.

##### LEFT JOIN

```sql
SELECT u.name, o.amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;

```

✅ 왼쪽 테이블(users)은 모두 표시, 오른쪽(orders)에 없으면 NULL.

##### RIGHT JOIN

```sql
SELECT u.name, o.amount
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id;
```

✅ 오른쪽 테이블(orders)은 모두 표시, 왼쪽(users)에 없으면 NULL.

##### FULL OUTER JOIN

```sql
SELECT u.name, o.amount
FROM users u
FULL OUTER JOIN orders o ON u.id = o.user_id;
```

✅ 두 테이블의 모든 데이터 표시, 일치하지 않으면 NULL.

#### 💡 조인의 원리

##### 중첩 루프 조인

```sql
SELECT *
FROM users u
JOIN orders o ON u.id = o.user_id;
```

✅ 한 테이블의 각 행을 기준으로, 다른 테이블의 모든 행을 반복 탐색하면서 조건이 맞는 데이터를 찾는 방식

##### 🔗 Javascript 로 표현한 내부 로직

```js
for (const user of users) {
  // 외부 루프
  for (const order of orders) {
    // 내부 루프
    if (user.id === order.user_id) {
      // 조인 조건 비교
      console.log(user.name, order.amount);
    }
  }
}
```

✅ 외부 루프에서는 첫 번째 테이블의 행을 하나씩 꺼내고, 내부 루프에서 두 번재 모든 행을 비교하여 조건이 일치할 경우, 결과에 포함시킨다.

##### 정렬 병합 조인

```sql
SELECT *
FROM users u
JOIN orders o ON u.id = o.user_id;
```

✅ 두 테이블을 조인 키로 정렬한 뒤, 병합 하면서 일치하는 행을 찾는 조인 방식

##### 🔗 Javascript 로 표현한 내부 로직

```js
// 두 테이블이 이미 id 기준으로 정렬되어 있다고 가정
let i = 0,
  j = 0;

while (i < users.length && j < orders.length) {
  if (users[i].id === orders[j].user_id) {
    console.log(users[i].name, orders[j].amount); // 결과
    j++; // 중복된 order가 있을 수도 있으므로 이동
  } else if (users[i].id < orders[j].user_id) {
    i++;
  } else {
    j++;
  }
}
```

✅ 각 테이블을 조인 키 기준으로 오름차순 정렬한 후, 두 테이블을 동시에 훑으면서 키를 비교하여 같으면 결과에 포함시키고, 작으면 작은 쪽 포인터를 한칸 이동시킨다.

##### 해시 조인

```sql
SELECT *
FROM users u
JOIN orders o ON u.id = o.user_id;
```

✅ 작은 쪽의 조인 키를 기준으로 해시 테이블을 만들고,
다른 테이블을 순회하며 해시를 이용해 빠르게 매칭하는 조인 방식.

##### 🔗 Javascript 로 표현한 내부 로직

```js
// Build 단계
const hash = new Map();
for (const user of users) {
  hash.set(user.id, user);
}

// Probe 단계
for (const order of orders) {
  if (hash.has(order.user_id)) {
    const user = hash.get(order.user_id);
    console.log(user.name, order.amount);
  }
}
```

✅ **Build 단계**
작은 테이블의 키를 기준으로 해시 테이블 생성

✅ **Probe 단계**
큰 테이블을 순회하면서, 해시 테이블에서 매칭되는 키를 탐색
